"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.Private = exports.Route = exports.Router = void 0;

var _react = _interopRequireDefault(require("react"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/concat"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _auth = require("@redwoodjs/auth");

var _internal = require("./internal");

var _splashPage = require("./splash-page");

// The guts of the router implementation.
const Route = () => {
  return null;
};
/**
 * `Routes` nested in `Private` require authentication.
 * When a user is not authenticated and attempts to visit this route they will be
 * redirected to `unauthenticated` route.
 */


exports.Route = Route;

const Private = () => {
  return null;
};

exports.Private = Private;
Private.propTypes = {
  /**
   * The page name where a user will be redirected when not authenticated.
   */
  unauthenticated: _propTypes.default.string.isRequired,
  role: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array])
};

const PrivatePageLoader = ({
  useAuth,
  unauthenticatedRoute,
  role,
  whileLoading = () => null,
  children
}) => {
  const {
    loading,
    isAuthenticated,
    hasRole
  } = useAuth();

  if (loading) {
    return whileLoading();
  }

  if (isAuthenticated && !role || isAuthenticated && role && hasRole(role)) {
    return children;
  } else {
    var _context, _context2;

    return /*#__PURE__*/_react.default.createElement(_internal.Redirect, {
      to: (0, _concat.default)(_context = (0, _concat.default)(_context2 = "".concat(unauthenticatedRoute(), "?redirectTo=")).call(_context2, window.location.pathname)).call(_context, encodeURIComponent(window.location.search))
    });
  }
};

const Router = props => /*#__PURE__*/_react.default.createElement(_internal.Location, null, locationContext => /*#__PURE__*/_react.default.createElement(RouterImpl, (0, _extends2.default)({}, locationContext, props)));
/**
 * Pages can be imported automatically or manually. Automatic imports are actually
 * objects and take the following form (which we call a 'spec'):
 *
 *   const WhateverPage = {
 *     name: 'WhateverPage',
 *     loader: () => import('src/pages/WhateverPage')
 *   }
 *
 * Manual imports simply load the page:
 *
 *   import WhateverPage from 'src/pages/WhateverPage'
 *
 * Before passing a "page" to the PageLoader, we will normalize the manually
 * imported version into a spec. */


exports.Router = Router;

const normalizePage = specOrPage => {
  if (specOrPage.loader) {
    // Already a spec, just return it.
    return specOrPage;
  } else {
    // Wrap the Page in a fresh spec, and put it in a promise to emulate
    // an async module import.
    return {
      name: specOrPage.name,
      loader: async () => ({
        default: specOrPage
      })
    };
  }
};

const DEFAULT_PAGE_LOADING_DELAY = 1000; // milliseconds

const Loaders = ({
  allParams,
  Page,
  pageLoadingDelay
}) => {
  return /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(Page),
    delay: pageLoadingDelay,
    params: allParams
  });
};

const RouterImpl = ({
  pathname,
  search,
  paramTypes,
  pageLoadingDelay = DEFAULT_PAGE_LOADING_DELAY,
  children,
  useAuth = _auth.useAuth
}) => {
  const routes = _react.default.useMemo(() => {
    var _context3, _context4, _context5, _context8;

    // Find `Private` components, mark their children `Route` components as private,
    // and merge them into a single array.
    const privateRoutes = (0, _reduce.default)(_context3 = (0, _map.default)(_context4 = (0, _filter.default)(_context5 = _react.default.Children.toArray(children)).call(_context5, child => child.type === Private)).call(_context4, privateElement => {
      var _context6, _context7;

      // Set `Route` props
      const {
        unauthenticated,
        role,
        children
      } = privateElement.props;
      return (0, _map.default)(_context6 = (0, _filter.default)(_context7 = _react.default.Children.toArray(children) // Make sure only valid routes are considered
      ).call(_context7, route => route.type === Route)).call(_context6, route => _react.default.cloneElement(route, {
        private: true,
        unauthenticatedRedirect: unauthenticated,
        role: role
      }));
    })).call(_context3, (a, b) => (0, _concat.default)(a).call(a, b), []) || [];
    const routes = [...privateRoutes, ...(0, _filter.default)(_context8 = _react.default.Children.toArray(children)).call(_context8, child => child.type === Route)];
    return routes;
  }, [children]);

  const namedRoutes = _react.default.useMemo(() => (0, _internal.mapNamedRoutes)(routes), [routes]);

  let NotFoundPage;

  for (let route of routes) {
    const {
      path,
      page: Page,
      redirect,
      notfound
    } = route.props;

    if (notfound) {
      NotFoundPage = Page;
      continue;
    }

    const {
      match,
      params: pathParams
    } = (0, _internal.matchPath)(path, pathname, paramTypes);

    if (match) {
      const searchParams = (0, _internal.parseSearch)(search);
      const allParams = { ...pathParams,
        ...searchParams
      };

      if (redirect) {
        const newPath = (0, _internal.replaceParams)(redirect, pathParams);
        (0, _internal.navigate)(newPath);
        return /*#__PURE__*/_react.default.createElement(RouterImpl, {
          pathname: newPath,
          search: search
        }, children);
      } else {
        var _route$props;

        if (route !== null && route !== void 0 && (_route$props = route.props) !== null && _route$props !== void 0 && _route$props.private) {
          if (typeof useAuth === 'undefined') {
            throw new Error("You're using a private route, but `useAuth` is undefined. Have you created an AuthProvider, or pased in the incorrect prop to `useAuth`?");
          }

          return /*#__PURE__*/_react.default.createElement(PrivatePageLoader, {
            useAuth: useAuth,
            unauthenticatedRoute: namedRoutes[route.props.unauthenticatedRedirect],
            whileLoading: route.props.whileLoading,
            role: route.props.role
          }, /*#__PURE__*/_react.default.createElement(Loaders, {
            allParams: allParams,
            Page: Page,
            pageLoadingDelay: pageLoadingDelay
          }));
        }

        return /*#__PURE__*/_react.default.createElement(Loaders, {
          allParams: allParams,
          Page: Page,
          pageLoadingDelay: pageLoadingDelay
        });
      }
    }
  } // If the router is being used in a Redwood app and only the notfound page is
  // specified, show the Redwood splash page.


  if (routes.length === 1 && NotFoundPage) {
    const isRedwood = typeof __REDWOOD__ !== 'undefined';
    return /*#__PURE__*/_react.default.createElement(_splashPage.SplashPage, {
      isRedwood: isRedwood
    });
  }

  return /*#__PURE__*/_react.default.createElement(_internal.ParamsContext.Provider, {
    value: {}
  }, /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(NotFoundPage)
  }));
};