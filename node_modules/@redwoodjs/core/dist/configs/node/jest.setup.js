"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/set"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/from"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/concat"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));

const path = require('path');

const {
  setContext
} = require('@redwoodjs/api');

const {
  getPaths
} = require('@redwoodjs/internal');

const {
  defineScenario
} = require('@redwoodjs/testing/dist/scenario');

const {
  db
} = require(path.join(getPaths().api.src, 'lib', 'db'));

const DEFAULT_SCENARIO = 'standard';
const PRISMA_RESERVED = ['create', 'connect'];

const findNestedModels = data => {
  let models = [];

  for (const [field, value] of (0, _entries.default)(data)) {
    if (typeof value === 'object') {
      if (!(0, _includes.default)(models).call(models, field) && !(0, _includes.default)(PRISMA_RESERVED).call(PRISMA_RESERVED, field)) {
        models.push(field);
      }

      models = (0, _concat.default)(models).call(models, findNestedModels(value));
    }
  }

  return models;
};

const seedScenario = async scenario => {
  if (scenario) {
    const scenarios = {};

    for (const [model, namedFixtures] of (0, _entries.default)(scenario)) {
      scenarios[model] = {};

      for (const [name, data] of (0, _entries.default)(namedFixtures)) {
        scenarios[model][name] = await db[model].create({
          data
        });
      }
    }

    return scenarios;
  } else {
    return {};
  }
};

const removeScenario = async scenario => {
  if (scenario) {
    let models = [];

    for (const [model, namedFixtures] of (0, _entries.default)(scenario)) {
      models.push(model);

      for (const [_name, data] of (0, _entries.default)(namedFixtures)) {
        models = (0, _concat.default)(models).call(models, findNestedModels(data));
      }
    } // get unique model names only


    models = (0, _from.default)(new _set.default(models));

    for (const model of models) {
      await db.$queryRaw(`DELETE FROM ${model}`);
    }
  }
};

window.scenario = (...args) => {
  let scenarioName, testName, testFunc;

  if (args.length === 3) {
    ;
    [scenarioName, testName, testFunc] = args;
  } else if (args.length === 2) {
    scenarioName = DEFAULT_SCENARIO;
    [testName, testFunc] = args;
  } else {
    throw new Error('scenario() requires 2 or 3 arguments');
  }

  return window.it(testName, async () => {
    const path = require('path');

    const testFileDir = path.parse(window.jasmine.testPath);
    const testFilePath = `${testFileDir.dir}/${testFileDir.name.split('.')[0]}.scenarios`;
    let allScenarios, scenario, result;

    try {
      allScenarios = require(testFilePath);
    } catch (e) {
      // ignore error if scenario file not found, otherwise re-throw
      if (e.code !== 'MODULE_NOT_FOUND') {
        throw e;
      }
    }

    if (allScenarios) {
      if (allScenarios[scenarioName]) {
        scenario = allScenarios[scenarioName];
      } else {
        throw 'UndefinedScenario', `There is no scenario named "${scenarioName}" in ${testFilePath}.js`;
      }
    }

    const scenarioData = await seedScenario(scenario);

    try {
      result = await testFunc(scenarioData);
    } finally {
      // if the test fails this makes sure we still remove scenario data
      await removeScenario(scenario);
    }

    return result;
  });
};

window.defineScenario = defineScenario;

window.mockCurrentUser = currentUser => {
  setContext({
    currentUser
  });
};

afterAll(async () => {
  await db.$disconnect();
});